import 'package:flutter/material.dart';
import '../../../core/app_theme.dart';

class PrecipitationGraphsScreen extends StatelessWidget {
  const PrecipitationGraphsScreen({
    super.key,
    required this.appTheme,
  });

  /// Uygulamanın o anki teması (MainScreen'den gönder)
  final AppTheme appTheme;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: appTheme.bg,
      appBar: AppBar(
        backgroundColor: appTheme.bg,
        elevation: 0,
        centerTitle: false,
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: appTheme.text),
          onPressed: () => Navigator.of(context).pop(),
        ),
        title: Text(
          'Precipitation Graphs',
          style: TextStyle(
            color: appTheme.text,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              Expanded(
                child: Row(
                  children: const [
                    Expanded(
                      child: _PrecipitationCard(
                        theme: AppTheme.light,
                        title: 'Chance of Precipitation',
                        subtitle: "Tuesday's chance: 16%",
                      ),
                    ),
                    SizedBox(width: 16),
                    Expanded(
                      child: _PrecipitationCard(
                        theme: AppTheme.dark,
                        title: 'Chance of Precipitation',
                        subtitle: "Tuesday's chance: 16%",
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'This screen illustrates the chance of precipitation across '
                'different hours of the day using a smooth line chart. The visual '
                'representation enables users to quickly interpret rainfall '
                'likelihood and timing. Both light and dark theme versions '
                'maintain visual clarity.',
                style: TextStyle(
                  color: appTheme.sub,
                  fontSize: 13,
                  height: 1.4,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _PrecipitationCard extends StatelessWidget {
  const _PrecipitationCard({
    required this.theme,
    required this.title,
    required this.subtitle,
  });

  final AppTheme theme;
  final String title;
  final String subtitle;

  @override
  Widget build(BuildContext context) {
    final values = <double>[0.05, 0.15, 0.30, 0.55, 0.75, 0.60, 0.35];

    return Container(
      decoration: BoxDecoration(
        color: theme.card,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(color: theme.border),
      ),
      padding: const EdgeInsets.all(16),
      child: Theme(
        data: theme.materialTheme,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header row
            Row(
              children: [
                Icon(
                  Icons.circle_outlined,
                  size: 18,
                  color: theme.sub,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    title,
                    style: TextStyle(
                      color: theme.text,
                      fontWeight: FontWeight.w600,
                      fontSize: 14,
                    ),
                  ),
                ),
                Icon(Icons.close, size: 18, color: theme.sub),
              ],
            ),
            const SizedBox(height: 12),
            // Graph
            Expanded(
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 8),
                child: CustomPaint(
                  painter: _SimpleLineChartPainter(
                    values: values,
                    lineColor: theme.accent,
                    gridColor: theme.border.withValues(alpha: 0.4),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: TextStyle(
                color: theme.sub,
                fontSize: 11,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Basit smooth çizgi grafiği
class _SimpleLineChartPainter extends CustomPainter {
  _SimpleLineChartPainter({
    required this.values,
    required this.lineColor,
    required this.gridColor,
  });

  final List<double> values; // 0..1 arası normalize
  final Color lineColor;
  final Color gridColor;

  @override
  void paint(Canvas canvas, Size size) {
    final padding = 12.0;
    final chartRect = Rect.fromLTWH(
      padding,
      padding,
      size.width - 2 * padding,
      size.height - 2 * padding,
    );

    // grid lines
    final gridPaint = Paint()
      ..color = gridColor
      ..strokeWidth = 1;

    for (int i = 1; i <= 3; i++) {
      final dy = chartRect.top + chartRect.height * i / 4;
      canvas.drawLine(
        Offset(chartRect.left, dy),
        Offset(chartRect.right, dy),
        gridPaint,
      );
    }

    // line
    if (values.length < 2) return;

    final path = Path();
    final stepX = chartRect.width / (values.length - 1);

    Offset pointFor(int i) {
      final x = chartRect.left + stepX * i;
      final y = chartRect.bottom - values[i] * chartRect.height;
      return Offset(x, y);
    }

    path.moveTo(pointFor(0).dx, pointFor(0).dy);
    for (int i = 1; i < values.length; i++) {
      final p0 = pointFor(i - 1);
      final p1 = pointFor(i);
      final mid = Offset(
        (p0.dx + p1.dx) / 2,
        (p0.dy + p1.dy) / 2,
      );
      path.quadraticBezierTo(p0.dx, p0.dy, mid.dx, mid.dy);
    }
    path.lineTo(pointFor(values.length - 1).dx,
        pointFor(values.length - 1).dy);

    final linePaint = Paint()
      ..color = lineColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.5
      ..strokeCap = StrokeCap.round;

    canvas.drawPath(path, linePaint);
  }

  @override
  bool shouldRepaint(covariant _SimpleLineChartPainter oldDelegate) {
    return oldDelegate.values != values ||
        oldDelegate.lineColor != lineColor ||
        oldDelegate.gridColor != gridColor;
  }
}
